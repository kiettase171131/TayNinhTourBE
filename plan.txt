# PH√ÇN T√çCH REVIEW V√Ä ƒê·ªÄ XU·∫§T C·∫¢I THI·ªÜN CHO TOUR TEMPLATE SYSTEM

## üìã PH√ÇN T√çCH REVIEW

### üéØ V·∫•n ƒë·ªÅ ch√≠nh c·∫ßn gi·∫£i quy·∫øt: T7/CN trong Template

Theo requirement ban ƒë·∫ßu, **dayOfWeek n√™n ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a c·ªë ƒë·ªãnh trong Template**, kh√¥ng ph·∫£i ch·ªçn l·∫°i khi t·∫°o slot.

**Requirement g·ªëc:**
- Template lu√¥n lu√¥n ch·ªâ cung c·∫•p th·ª© b·∫£y v√† ch·ªß nh·∫≠t ƒë·ªÉ ch·ªçn (ch·ªâ ch·ªçn 1 trong 2)
- Kh√¥ng ƒë∆∞·ª£c ch·ªçn c√°c ng√†y kh√°c
- Khi t·∫°o slot ch·ªâ c·∫ßn ch·ªçn th√°ng/nƒÉm, h·ªá th·ªëng t·ª± ƒë·ªông d√πng ng√†y ƒë√£ ƒë·ªãnh trong template

---

## üîß C√ÅC C·∫¢I THI·ªÜN C·∫¶N TH·ª∞C HI·ªÜN

### 1. ‚úÖ ƒêI·ªÄU ƒê√É T·ªêT (Kh√¥ng c·∫ßn thay ƒë·ªïi)
- `TourTemplate.ScheduleDays` ƒë√£ c√≥ s·∫µn ‚úÖ
- `TourTemplateScheduleValidator` ƒë√£ validate ch·ªâ cho ph√©p T7 ho·∫∑c CN ‚úÖ
- `RequestCreateTourTemplateDto.ScheduleDays` ƒë√£ c√≥ validation ‚úÖ

### 2. üîß C·∫¢I THI·ªÜN C·∫¶N TH·ª∞C HI·ªÜN

#### A. C·∫£i thi·ªán TourSlot Generation Logic

**V·∫•n ƒë·ªÅ hi·ªán t·∫°i:**
- C√≥ 3 DTO kh√°c nhau cho vi·ªác generate slots
- API `POST /api/TourSlot/generate` v·∫´n y√™u c·∫ßu client g·ª≠i `ScheduleDays`
- Logic kh√¥ng nh·∫•t qu√°n gi·ªØa c√°c service

**3 DTO g√¢y confusion:**
- `RequestGenerateSlotsDto` (TourSlot) - c√≥ `ScheduleDays`
- `RequestGenerateSlotsDto` (TourCompany) - c√≥ `ScheduleDay`
- `RequestGenerateSlotDatesDto` (Scheduling) - c√≥ `ScheduleDays`

**Gi·∫£i ph√°p:**

```typescript
// ‚ùå HI·ªÜN T·∫†I (Sai logic)
{
  "tourTemplateId": "uuid",
  "month": 6,
  "year": 2025,
  "scheduleDays": "Saturday"  // ‚Üê KH√îNG C·∫¶N THI·∫æT
}

// ‚úÖ N√äN L√Ä (ƒê√∫ng logic)
{
  "tourTemplateId": "uuid",
  "month": 6,
  "year": 2025
  // scheduleDays s·∫Ω ƒë∆∞·ª£c l·∫•y t·ª´ TourTemplate
}
```

#### B. C·∫£i thi·ªán Service Logic

**C·∫ßn s·ª≠a TourSlotService.GenerateSlotsAsync():**

```csharp
public async Task<ResponseGenerateSlotsDto> GenerateSlotsAsync(RequestGenerateSlotsDto request)
{
    // 1. L·∫•y template ƒë·ªÉ get ScheduleDays
    var template = await _unitOfWork.TourTemplateRepository.GetByIdAsync(request.TourTemplateId);
    if (template == null)
    {
        return new ResponseGenerateSlotsDto
        {
            IsSuccess = false,
            Message = "Template kh√¥ng t·ªìn t·∫°i"
        };
    }

    // 2. S·ª≠ d·ª•ng ScheduleDays t·ª´ template thay v√¨ t·ª´ request
    var weekendDates = _schedulingService.CalculateWeekendDates(
        request.Year,
        request.Month,
        template.ScheduleDays  // ‚Üê L·∫•y t·ª´ template
    );

    // 3. Ti·∫øp t·ª•c logic generate...
}
```

#### C. C·∫£i thi·ªán Frontend UX

**FLOW 3 ƒë∆∞·ª£c c·∫£i thi·ªán:**
```
[Ch·ªçn Template]
    ‚Üì
[Hi·ªÉn th·ªã: "Template n√†y ch·∫°y v√†o: Th·ª© 7"] ‚Üê Th√¥ng tin t·ª´ template
    ‚Üì
[Ch·ªçn th√°ng/nƒÉm]
    ‚Üì
[Preview: "S·∫Ω t·∫°o 4 slots v√†o c√°c ng√†y Th·ª© 7: 1/6, 8/6, 15/6, 22/6"]
    ‚Üì
[X√°c nh·∫≠n t·∫°o slots]
```

#### D. C·∫£i thi·ªán API Documentation

**C·∫≠p nh·∫≠t OpenAPI spec:**
```yaml
GenerateSlotsRequest:
  type: object
  required:
    - tourTemplateId
    - month
    - year
  properties:
    tourTemplateId:
      type: string
      format: uuid
      description: Tour template ID (ScheduleDays will be taken from template)
    month:
      type: integer
      minimum: 1
      maximum: 12
    year:
      type: integer
      minimum: 2025
    # Removed scheduleDays - will be taken from template
```

#### E. Th√™m API TourOperation (Thi·∫øu 15%)

**C·∫ßn t·∫°o TourOperationController:**

```csharp
[Route("api/[controller]")]
[ApiController]
[Authorize(Roles = Constants.RoleTourCompanyName)]
public class TourOperationController : ControllerBase
{
    [HttpPost]
    public async Task<ActionResult<ResponseCreateOperationDto>> CreateOperation(RequestCreateOperationDto request)

    [HttpGet("slot/{slotId}")]
    public async Task<ActionResult<TourOperationDto>> GetOperationBySlot(Guid slotId)

    [HttpPatch("{id}")]
    public async Task<ActionResult<ResponseUpdateOperationDto>> UpdateOperation(Guid id, RequestUpdateOperationDto request)

    [HttpDelete("{id}")]
    public async Task<ActionResult<BaseResponseDto>> DeleteOperation(Guid id)
}
```

**APIs c·∫ßn implement:**
- `POST /api/TourOperation` - Create operation
- `GET /api/TourOperation/slot/{slotId}` - Get operation by slot
- `PATCH /api/TourOperation/{id}` - Update operation
- `DELETE /api/TourOperation/{id}` - Delete operation

#### F. Th√™m User/Guide Selection API

**C·∫ßn th√™m v√†o AccountController ho·∫∑c t·∫°o UserController:**

```csharp
[HttpGet("guides")]
[Authorize(Roles = Constants.RoleTourCompanyName)]
public async Task<ActionResult<List<GuideDto>>> GetAvailableGuides()

[HttpGet("guides/available")]
public async Task<ActionResult<List<GuideDto>>> GetAvailableGuidesForDate(DateOnly date)
```

**APIs c·∫ßn implement:**
- `GET /api/User/guides` - L·∫•y danh s√°ch h∆∞·ªõng d·∫´n vi√™n
- `GET /api/User/tourcompany-users` - L·∫•y users thu·ªôc tour company
- `GET /api/User/guides/available?date=2025-06-01` - L·∫•y guides available cho ng√†y c·ª• th·ªÉ

---

## üìã TASK BREAKDOWN CHI TI·∫æT

### üî• TASK 1: S·ª≠a RequestGenerateSlotsDto (15 ph√∫t)
**M·ª•c ti√™u:** Lo·∫°i b·ªè ScheduleDays t·ª´ request DTO

**Files c·∫ßn s·ª≠a:**
- `TayNinhTourApi.BusinessLogicLayer\DTOs\Request\TourSlot\RequestGenerateSlotsDto.cs`

**Thay ƒë·ªïi:**
```csharp
// X√ìA d√≤ng n√†y:
public ScheduleDay ScheduleDays { get; set; } = ScheduleDay.Saturday | ScheduleDay.Sunday;
```

**Test:** Compile project th√†nh c√¥ng

---

### üî• TASK 2: S·ª≠a TourSlotService Logic (30 ph√∫t)
**M·ª•c ti√™u:** L·∫•y ScheduleDays t·ª´ Template thay v√¨ request

**Context:** Hi·ªán t·∫°i client ph·∫£i g·ª≠i ScheduleDays trong request, nh∆∞ng theo requirement th√¨ ng√†y ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh s·∫µn trong Template. Logic n√†y sai v√† g√¢y confusion.

**Files c·∫ßn s·ª≠a:**
- `TayNinhTourApi.BusinessLogicLayer\Services\TourSlotService.cs`

**Logic chi ti·∫øt:**
1. **Validate Template t·ªìn t·∫°i** tr∆∞·ªõc khi generate
2. **L·∫•y ScheduleDays t·ª´ Template** thay v√¨ request
3. **Validate Template.ScheduleDays** ph·∫£i l√† Saturday ho·∫∑c Sunday
4. **Generate slots** d·ª±a tr√™n ng√†y c·ªë ƒë·ªãnh t·ª´ template

**Thay ƒë·ªïi trong GenerateSlotsAsync():**
```csharp
// TH√äM: Validate template t·ªìn t·∫°i
var template = await _unitOfWork.TourTemplateRepository.GetByIdAsync(request.TourTemplateId);
if (template == null)
{
    return new ResponseGenerateSlotsDto
    {
        IsSuccess = false,
        Message = "Template kh√¥ng t·ªìn t·∫°i"
    };
}

// TH√äM: Validate template c√≥ ScheduleDays h·ª£p l·ªá
var validationResult = TourTemplateScheduleValidator.ValidateScheduleDay(template.ScheduleDays);
if (!validationResult.IsValid)
{
    return new ResponseGenerateSlotsDto
    {
        IsSuccess = false,
        Message = $"Template c√≥ ng√†y kh√¥ng h·ª£p l·ªá: {validationResult.ErrorMessage}"
    };
}

// S·ª¨A: D√πng template.ScheduleDays thay v√¨ request.ScheduleDays
var weekendDates = _schedulingService.CalculateWeekendDates(
    request.Year,
    request.Month,
    template.ScheduleDays  // ‚Üê T·ª´ template, kh√¥ng t·ª´ request
);

// TH√äM: Log ƒë·ªÉ debug
_logger.LogInformation("Generating slots for template {TemplateId} on {ScheduleDay} for {Month}/{Year}",
    template.Id, template.ScheduleDays, request.Month, request.Year);
```

**Business Logic:**
- Template v·ªõi ScheduleDays = Saturday ‚Üí Ch·ªâ t·∫°o slots v√†o c√°c th·ª© 7
- Template v·ªõi ScheduleDays = Sunday ‚Üí Ch·ªâ t·∫°o slots v√†o c√°c ch·ªß nh·∫≠t
- T·ªëi ƒëa 4 slots per month (4 tu·∫ßn)
- Skip c√°c ng√†y ƒë√£ qua n·∫øu t·∫°o cho th√°ng hi·ªán t·∫°i

**Test:**
1. API POST /api/TourSlot/generate kh√¥ng c·∫ßn ScheduleDays trong request
2. Slots ƒë∆∞·ª£c t·∫°o ƒë√∫ng ng√†y theo template
3. Error message r√µ r√†ng khi template kh√¥ng t·ªìn t·∫°i

---

### üî• TASK 3: T·∫°o TourOperation DTOs (20 ph√∫t)
**M·ª•c ti√™u:** T·∫°o DTOs cho TourOperation CRUD

**Context:** TourOperation l∆∞u th√¥ng tin v·∫≠n h√†nh cho m·ªói TourSlot c·ª• th·ªÉ: h∆∞·ªõng d·∫´n vi√™n, gi√°, s·ªë gh·∫ø, m√¥ t·∫£. ƒê√¢y l√† b∆∞·ªõc cu·ªëi ƒë·ªÉ TourSlot s·∫µn s√†ng cho kh√°ch ƒë·∫∑t.

**Business Logic:**
- **1 TourSlot = 1 TourOperation** (one-to-one relationship)
- **GuideId optional** (c√≥ th·ªÉ ch∆∞a assign guide)
- **Price override** template price (c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh gi√° theo slot c·ª• th·ªÉ)
- **MaxSeats** kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° template.MaxGuests
- **Status tracking** (Draft, Active, Cancelled)

**Files c·∫ßn t·∫°o:**

**1. RequestCreateOperationDto.cs:**
```csharp
using System.ComponentModel.DataAnnotations;

public class RequestCreateOperationDto
{
    [Required(ErrorMessage = "TourSlotId l√† b·∫Øt bu·ªôc")]
    public Guid TourSlotId { get; set; }

    [Required(ErrorMessage = "Gi√° tour l√† b·∫Øt bu·ªôc")]
    [Range(0, double.MaxValue, ErrorMessage = "Gi√° ph·∫£i >= 0")]
    public decimal Price { get; set; }

    [Required(ErrorMessage = "S·ªë gh·∫ø t·ªëi ƒëa l√† b·∫Øt bu·ªôc")]
    [Range(1, 100, ErrorMessage = "S·ªë gh·∫ø ph·∫£i t·ª´ 1-100")]
    public int MaxSeats { get; set; }

    [StringLength(1000, ErrorMessage = "M√¥ t·∫£ kh√¥ng qu√° 1000 k√Ω t·ª±")]
    public string? Description { get; set; }

    public Guid? GuideId { get; set; }

    [StringLength(500, ErrorMessage = "Ghi ch√∫ kh√¥ng qu√° 500 k√Ω t·ª±")]
    public string? Notes { get; set; }

    public bool IsActive { get; set; } = true;
}
```

**2. RequestUpdateOperationDto.cs:**
```csharp
public class RequestUpdateOperationDto
{
    [Range(0, double.MaxValue, ErrorMessage = "Gi√° ph·∫£i >= 0")]
    public decimal? Price { get; set; }

    [Range(1, 100, ErrorMessage = "S·ªë gh·∫ø ph·∫£i t·ª´ 1-100")]
    public int? MaxSeats { get; set; }

    [StringLength(1000, ErrorMessage = "M√¥ t·∫£ kh√¥ng qu√° 1000 k√Ω t·ª±")]
    public string? Description { get; set; }

    public Guid? GuideId { get; set; }

    [StringLength(500, ErrorMessage = "Ghi ch√∫ kh√¥ng qu√° 500 k√Ω t·ª±")]
    public string? Notes { get; set; }

    public bool? IsActive { get; set; }
}
```

**3. TourOperationDto.cs:**
```csharp
public class TourOperationDto
{
    public Guid Id { get; set; }
    public Guid TourSlotId { get; set; }
    public decimal Price { get; set; }
    public int MaxSeats { get; set; }
    public int BookedSeats { get; set; } = 0;
    public string? Description { get; set; }
    public Guid? GuideId { get; set; }
    public string? GuideName { get; set; }
    public string? GuidePhone { get; set; }
    public string? Notes { get; set; }
    public bool IsActive { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }

    // Navigation properties
    public TourSlotDto? TourSlot { get; set; }
}
```

**4. ResponseCreateOperationDto.cs:**
```csharp
public class ResponseCreateOperationDto : BaseResponseDto
{
    public TourOperationDto? Operation { get; set; }
    public string? ValidationErrors { get; set; }
}
```

**Validation Logic:**
- TourSlot ph·∫£i t·ªìn t·∫°i v√† ch∆∞a c√≥ Operation
- MaxSeats <= Template.MaxGuests
- GuideId ph·∫£i t·ªìn t·∫°i trong h·ªá th·ªëng (n·∫øu c√≥)
- Price >= 0

**Test:** Compile project th√†nh c√¥ng, DTOs c√≥ validation attributes ƒë·∫ßy ƒë·ªß

---

### üî• TASK 4: T·∫°o TourOperationService Interface (15 ph√∫t)
**M·ª•c ti√™u:** T·∫°o service interface cho TourOperation

**Context:** Interface ƒë·ªãnh nghƒ©a contract cho TourOperation business logic. C·∫ßn cover ƒë·∫ßy ƒë·ªß CRUD operations v√† business rules.

**Files c·∫ßn t·∫°o:**
- `TayNinhTourApi.BusinessLogicLayer\Services\Interfaces\ITourOperationService.cs`

**Interface ƒë·∫ßy ƒë·ªß:**
```csharp
using TayNinhTourApi.BusinessLogicLayer.DTOs.Request.TourOperation;
using TayNinhTourApi.BusinessLogicLayer.DTOs.Response.TourOperation;
using TayNinhTourApi.BusinessLogicLayer.DTOs.Response;

namespace TayNinhTourApi.BusinessLogicLayer.Services.Interfaces
{
    /// <summary>
    /// Service interface cho qu·∫£n l√Ω TourOperation
    /// TourOperation ch·ª©a th√¥ng tin v·∫≠n h√†nh c·ª• th·ªÉ cho m·ªói TourSlot
    /// </summary>
    public interface ITourOperationService
    {
        /// <summary>
        /// T·∫°o operation m·ªõi cho TourSlot
        /// Business Rules:
        /// - TourSlot ph·∫£i t·ªìn t·∫°i v√† ch∆∞a c√≥ Operation
        /// - MaxSeats <= Template.MaxGuests
        /// - GuideId ph·∫£i valid (n·∫øu c√≥)
        /// - Price >= 0
        /// </summary>
        Task<ResponseCreateOperationDto> CreateOperationAsync(RequestCreateOperationDto request);

        /// <summary>
        /// L·∫•y operation theo TourSlot ID
        /// Return null n·∫øu slot ch∆∞a c√≥ operation
        /// </summary>
        Task<TourOperationDto?> GetOperationBySlotAsync(Guid slotId);

        /// <summary>
        /// L·∫•y operation theo Operation ID
        /// </summary>
        Task<TourOperationDto?> GetOperationByIdAsync(Guid operationId);

        /// <summary>
        /// C·∫≠p nh·∫≠t operation
        /// Business Rules:
        /// - Kh√¥ng ƒë∆∞·ª£c update n·∫øu c√≥ booking active
        /// - MaxSeats >= BookedSeats hi·ªán t·∫°i
        /// - GuideId ph·∫£i valid (n·∫øu thay ƒë·ªïi)
        /// </summary>
        Task<ResponseUpdateOperationDto> UpdateOperationAsync(Guid id, RequestUpdateOperationDto request);

        /// <summary>
        /// X√≥a operation
        /// Business Rules:
        /// - Kh√¥ng ƒë∆∞·ª£c x√≥a n·∫øu c√≥ booking
        /// - Soft delete (set IsActive = false)
        /// </summary>
        Task<BaseResponseDto> DeleteOperationAsync(Guid id);

        /// <summary>
        /// L·∫•y danh s√°ch operations v·ªõi filtering
        /// </summary>
        Task<List<TourOperationDto>> GetOperationsAsync(
            Guid? tourTemplateId = null,
            Guid? guideId = null,
            DateTime? fromDate = null,
            DateTime? toDate = null,
            bool includeInactive = false);

        /// <summary>
        /// Validate business rules cho operation
        /// </summary>
        Task<(bool IsValid, string ErrorMessage)> ValidateOperationAsync(RequestCreateOperationDto request);

        /// <summary>
        /// Check xem slot c√≥ th·ªÉ t·∫°o operation kh√¥ng
        /// </summary>
        Task<bool> CanCreateOperationForSlotAsync(Guid slotId);
    }
}
```

**Business Logic c·∫ßn implement:**
1. **One-to-One relationship**: 1 TourSlot ch·ªâ c√≥ 1 TourOperation
2. **Capacity validation**: MaxSeats <= Template.MaxGuests
3. **Guide validation**: GuideId ph·∫£i t·ªìn t·∫°i v√† available
4. **Booking protection**: Kh√¥ng ƒë∆∞·ª£c s·ª≠a/x√≥a n·∫øu c√≥ booking
5. **Price validation**: Price >= 0, c√≥ th·ªÉ override template price

**Test:** Compile project th√†nh c√¥ng, interface methods ƒë·∫ßy ƒë·ªß

---

### ÔøΩ TASK 5: Implement TourOperationService (45 ph√∫t)
**M·ª•c ti√™u:** Implement service logic cho TourOperation

**Context:** Core business logic cho TourOperation management. C·∫ßn implement ƒë·∫ßy ƒë·ªß validation, error handling, v√† integration v·ªõi c√°c services kh√°c.

**Files c·∫ßn t·∫°o:**
- `TayNinhTourApi.BusinessLogicLayer\Services\TourOperationService.cs`

**Dependencies c·∫ßn inject:**
```csharp
private readonly IUnitOfWork _unitOfWork;
private readonly IMapper _mapper;
private readonly ILogger<TourOperationService> _logger;
```

**Key Methods Implementation:**

**1. CreateOperationAsync() Logic:**
```csharp
public async Task<ResponseCreateOperationDto> CreateOperationAsync(RequestCreateOperationDto request)
{
    // 1. Validate TourSlot exists
    var tourSlot = await _unitOfWork.TourSlotRepository.GetByIdAsync(request.TourSlotId);
    if (tourSlot == null)
        return Error("TourSlot kh√¥ng t·ªìn t·∫°i");

    // 2. Check slot ch∆∞a c√≥ operation
    var existingOperation = await _unitOfWork.TourOperationRepository.GetByTourSlotIdAsync(request.TourSlotId);
    if (existingOperation != null)
        return Error("TourSlot ƒë√£ c√≥ operation");

    // 3. Validate v·ªõi Template constraints
    var template = await _unitOfWork.TourTemplateRepository.GetByIdAsync(tourSlot.TourTemplateId);
    if (request.MaxSeats > template.MaxGuests)
        return Error($"S·ªë gh·∫ø kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {template.MaxGuests}");

    // 4. Validate Guide (n·∫øu c√≥)
    if (request.GuideId.HasValue)
    {
        var guide = await _unitOfWork.UserRepository.GetByIdAsync(request.GuideId.Value);
        if (guide == null || guide.Role.Name != "Guide")
            return Error("Guide kh√¥ng h·ª£p l·ªá");
    }

    // 5. Create operation
    var operation = _mapper.Map<TourOperation>(request);
    operation.Id = Guid.NewGuid();
    operation.CreatedAt = DateTime.UtcNow;

    await _unitOfWork.TourOperationRepository.AddAsync(operation);
    await _unitOfWork.SaveChangesAsync();

    // 6. Return response
    var operationDto = _mapper.Map<TourOperationDto>(operation);
    return new ResponseCreateOperationDto
    {
        IsSuccess = true,
        Message = "T·∫°o operation th√†nh c√¥ng",
        Operation = operationDto
    };
}
```

**2. GetOperationBySlotAsync() Logic:**
```csharp
public async Task<TourOperationDto?> GetOperationBySlotAsync(Guid slotId)
{
    var operation = await _unitOfWork.TourOperationRepository.GetByTourSlotIdAsync(slotId);
    if (operation == null) return null;

    // Include related data
    var operationWithIncludes = await _unitOfWork.TourOperationRepository
        .GetByIdWithIncludesAsync(operation.Id,
            include: o => o.Include(x => x.TourSlot)
                          .Include(x => x.Guide));

    return _mapper.Map<TourOperationDto>(operationWithIncludes);
}
```

**3. UpdateOperationAsync() Logic:**
```csharp
public async Task<ResponseUpdateOperationDto> UpdateOperationAsync(Guid id, RequestUpdateOperationDto request)
{
    // 1. Get existing operation
    var operation = await _unitOfWork.TourOperationRepository.GetByIdAsync(id);
    if (operation == null)
        return Error("Operation kh√¥ng t·ªìn t·∫°i");

    // 2. Check c√≥ booking kh√¥ng (business rule)
    var bookingCount = await _unitOfWork.BookingRepository.CountByOperationIdAsync(id);
    if (bookingCount > 0 && request.MaxSeats.HasValue && request.MaxSeats < operation.MaxSeats)
        return Error("Kh√¥ng th·ªÉ gi·∫£m s·ªë gh·∫ø khi ƒë√£ c√≥ booking");

    // 3. Validate constraints
    if (request.MaxSeats.HasValue)
    {
        var tourSlot = await _unitOfWork.TourSlotRepository.GetByIdAsync(operation.TourSlotId);
        var template = await _unitOfWork.TourTemplateRepository.GetByIdAsync(tourSlot.TourTemplateId);

        if (request.MaxSeats > template.MaxGuests)
            return Error($"S·ªë gh·∫ø kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {template.MaxGuests}");
    }

    // 4. Update fields
    if (request.Price.HasValue) operation.Price = request.Price.Value;
    if (request.MaxSeats.HasValue) operation.MaxSeats = request.MaxSeats.Value;
    if (request.Description != null) operation.Description = request.Description;
    if (request.GuideId.HasValue) operation.GuideId = request.GuideId;
    if (request.Notes != null) operation.Notes = request.Notes;
    if (request.IsActive.HasValue) operation.IsActive = request.IsActive.Value;

    operation.UpdatedAt = DateTime.UtcNow;

    await _unitOfWork.TourOperationRepository.UpdateAsync(operation);
    await _unitOfWork.SaveChangesAsync();

    return Success("C·∫≠p nh·∫≠t operation th√†nh c√¥ng");
}
```

**4. DeleteOperationAsync() Logic:**
```csharp
public async Task<BaseResponseDto> DeleteOperationAsync(Guid id)
{
    var operation = await _unitOfWork.TourOperationRepository.GetByIdAsync(id);
    if (operation == null)
        return Error("Operation kh√¥ng t·ªìn t·∫°i");

    // Check c√≥ booking kh√¥ng
    var bookingCount = await _unitOfWork.BookingRepository.CountByOperationIdAsync(id);
    if (bookingCount > 0)
        return Error("Kh√¥ng th·ªÉ x√≥a operation ƒë√£ c√≥ booking");

    // Soft delete
    operation.IsActive = false;
    operation.UpdatedAt = DateTime.UtcNow;

    await _unitOfWork.TourOperationRepository.UpdateAsync(operation);
    await _unitOfWork.SaveChangesAsync();

    return Success("X√≥a operation th√†nh c√¥ng");
}
```

**Error Handling Pattern:**
```csharp
private ResponseCreateOperationDto Error(string message) => new()
{
    IsSuccess = false,
    Message = message
};

private ResponseUpdateOperationDto Success(string message) => new()
{
    IsSuccess = true,
    Message = message
};
```

**Test:**
1. Service methods compile v√† inject ƒë√∫ng dependencies
2. Validation logic ho·∫°t ƒë·ªông ƒë√∫ng
3. Repository calls ƒë∆∞·ª£c th·ª±c hi·ªán
4. AutoMapper mapping th√†nh c√¥ng

---

### üî• TASK 6: T·∫°o TourOperationController (30 ph√∫t)
**M·ª•c ti√™u:** T·∫°o controller v·ªõi 4 endpoints

**Context:** REST API controller cho TourOperation management. C·∫ßn follow chu·∫©n RESTful v√† c√≥ ƒë·∫ßy ƒë·ªß documentation, authorization, validation.

**Files c·∫ßn t·∫°o:**
- `TayNinhTourApi.Controller\Controllers\TourOperationController.cs`

**Controller Implementation:**
```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using TayNinhTourApi.BusinessLogicLayer.Services.Interfaces;
using TayNinhTourApi.BusinessLogicLayer.DTOs.Request.TourOperation;
using TayNinhTourApi.BusinessLogicLayer.DTOs.Response.TourOperation;
using TayNinhTourApi.BusinessLogicLayer.DTOs.Response;
using TayNinhTourApi.DataAccessLayer.Constants;

namespace TayNinhTourApi.Controller.Controllers
{
    /// <summary>
    /// Controller qu·∫£n l√Ω TourOperation - th√¥ng tin v·∫≠n h√†nh cho TourSlot
    /// </summary>
    [Route("api/[controller]")]
    [ApiController]
    [Authorize(Roles = Constants.RoleTourCompanyName)]
    public class TourOperationController : ControllerBase
    {
        private readonly ITourOperationService _tourOperationService;
        private readonly ILogger<TourOperationController> _logger;

        public TourOperationController(
            ITourOperationService tourOperationService,
            ILogger<TourOperationController> logger)
        {
            _tourOperationService = tourOperationService;
            _logger = logger;
        }

        /// <summary>
        /// T·∫°o operation m·ªõi cho TourSlot
        /// </summary>
        /// <param name="request">Th√¥ng tin operation</param>
        /// <returns>Operation ƒë∆∞·ª£c t·∫°o</returns>
        [HttpPost]
        [ProducesResponseType(typeof(ResponseCreateOperationDto), 200)]
        [ProducesResponseType(typeof(BaseResponseDto), 400)]
        public async Task<ActionResult<ResponseCreateOperationDto>> CreateOperation(
            [FromBody] RequestCreateOperationDto request)
        {
            try
            {
                _logger.LogInformation("Creating operation for slot {SlotId}", request.TourSlotId);

                if (!ModelState.IsValid)
                {
                    return BadRequest(new BaseResponseDto
                    {
                        IsSuccess = false,
                        Message = "D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá",
                        Data = ModelState
                    });
                }

                var result = await _tourOperationService.CreateOperationAsync(request);

                if (!result.IsSuccess)
                {
                    return BadRequest(result);
                }

                _logger.LogInformation("Operation created successfully for slot {SlotId}", request.TourSlotId);
                return Ok(result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating operation for slot {SlotId}", request.TourSlotId);
                return StatusCode(500, new BaseResponseDto
                {
                    IsSuccess = false,
                    Message = "L·ªói h·ªá th·ªëng khi t·∫°o operation"
                });
            }
        }

        /// <summary>
        /// L·∫•y operation theo TourSlot ID
        /// </summary>
        /// <param name="slotId">ID c·ªßa TourSlot</param>
        /// <returns>Operation c·ªßa slot</returns>
        [HttpGet("slot/{slotId:guid}")]
        [ProducesResponseType(typeof(TourOperationDto), 200)]
        [ProducesResponseType(404)]
        public async Task<ActionResult<TourOperationDto>> GetOperationBySlot(Guid slotId)
        {
            try
            {
                _logger.LogInformation("Getting operation for slot {SlotId}", slotId);

                var operation = await _tourOperationService.GetOperationBySlotAsync(slotId);

                if (operation == null)
                {
                    return NotFound(new BaseResponseDto
                    {
                        IsSuccess = false,
                        Message = "Slot ch∆∞a c√≥ operation"
                    });
                }

                return Ok(operation);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting operation for slot {SlotId}", slotId);
                return StatusCode(500, new BaseResponseDto
                {
                    IsSuccess = false,
                    Message = "L·ªói h·ªá th·ªëng khi l·∫•y operation"
                });
            }
        }

        /// <summary>
        /// C·∫≠p nh·∫≠t operation
        /// </summary>
        /// <param name="id">ID c·ªßa operation</param>
        /// <param name="request">Th√¥ng tin c·∫≠p nh·∫≠t</param>
        /// <returns>K·∫øt qu·∫£ c·∫≠p nh·∫≠t</returns>
        [HttpPatch("{id:guid}")]
        [ProducesResponseType(typeof(ResponseUpdateOperationDto), 200)]
        [ProducesResponseType(typeof(BaseResponseDto), 400)]
        [ProducesResponseType(404)]
        public async Task<ActionResult<ResponseUpdateOperationDto>> UpdateOperation(
            Guid id,
            [FromBody] RequestUpdateOperationDto request)
        {
            try
            {
                _logger.LogInformation("Updating operation {OperationId}", id);

                if (!ModelState.IsValid)
                {
                    return BadRequest(new BaseResponseDto
                    {
                        IsSuccess = false,
                        Message = "D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá",
                        Data = ModelState
                    });
                }

                var result = await _tourOperationService.UpdateOperationAsync(id, request);

                if (!result.IsSuccess)
                {
                    if (result.Message.Contains("kh√¥ng t·ªìn t·∫°i"))
                        return NotFound(result);
                    return BadRequest(result);
                }

                _logger.LogInformation("Operation {OperationId} updated successfully", id);
                return Ok(result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating operation {OperationId}", id);
                return StatusCode(500, new BaseResponseDto
                {
                    IsSuccess = false,
                    Message = "L·ªói h·ªá th·ªëng khi c·∫≠p nh·∫≠t operation"
                });
            }
        }

        /// <summary>
        /// X√≥a operation (soft delete)
        /// </summary>
        /// <param name="id">ID c·ªßa operation</param>
        /// <returns>K·∫øt qu·∫£ x√≥a</returns>
        [HttpDelete("{id:guid}")]
        [ProducesResponseType(typeof(BaseResponseDto), 200)]
        [ProducesResponseType(typeof(BaseResponseDto), 400)]
        [ProducesResponseType(404)]
        public async Task<ActionResult<BaseResponseDto>> DeleteOperation(Guid id)
        {
            try
            {
                _logger.LogInformation("Deleting operation {OperationId}", id);

                var result = await _tourOperationService.DeleteOperationAsync(id);

                if (!result.IsSuccess)
                {
                    if (result.Message.Contains("kh√¥ng t·ªìn t·∫°i"))
                        return NotFound(result);
                    return BadRequest(result);
                }

                _logger.LogInformation("Operation {OperationId} deleted successfully", id);
                return Ok(result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting operation {OperationId}", id);
                return StatusCode(500, new BaseResponseDto
                {
                    IsSuccess = false,
                    Message = "L·ªói h·ªá th·ªëng khi x√≥a operation"
                });
            }
        }
    }
}
```

**API Endpoints:**
- `POST /api/TourOperation` - T·∫°o operation m·ªõi
- `GET /api/TourOperation/slot/{slotId}` - L·∫•y operation theo slot
- `PATCH /api/TourOperation/{id}` - C·∫≠p nh·∫≠t operation
- `DELETE /api/TourOperation/{id}` - X√≥a operation (soft delete)

**Authorization:** Ch·ªâ TourCompany role ƒë∆∞·ª£c ph√©p truy c·∫≠p

**Error Handling:**
- 400 Bad Request: Validation errors, business rule violations
- 404 Not Found: Operation/Slot kh√¥ng t·ªìn t·∫°i
- 500 Internal Server Error: System errors

**Test:**
1. Swagger hi·ªÉn th·ªã 4 endpoints m·ªõi v·ªõi documentation ƒë·∫ßy ƒë·ªß
2. Authorization middleware ho·∫°t ƒë·ªông
3. Model validation ƒë∆∞·ª£c trigger
4. Error responses c√≥ format nh·∫•t qu√°n

---

### üî• TASK 7: ƒêƒÉng k√Ω DI cho TourOperation (10 ph√∫t)
**M·ª•c ti√™u:** ƒêƒÉng k√Ω services trong Program.cs

**Files c·∫ßn s·ª≠a:**
- `TayNinhTourApi.Controller\Program.cs`

**Th√™m:**
```csharp
builder.Services.AddScoped<ITourOperationService, TourOperationService>();
```

**Test:** Application start th√†nh c√¥ng

---

### ÔøΩ TASK 8: T·∫°o Guide DTOs (15 ph√∫t)
**M·ª•c ti√™u:** T·∫°o DTOs cho Guide selection

**Context:** DTOs cho vi·ªác hi·ªÉn th·ªã v√† ch·ªçn h∆∞·ªõng d·∫´n vi√™n trong dropdown khi t·∫°o TourOperation. C·∫ßn th√¥ng tin c∆° b·∫£n v√† tr·∫°ng th√°i available.

**Files c·∫ßn t·∫°o:**
- `TayNinhTourApi.BusinessLogicLayer\DTOs\Response\User\GuideDto.cs`

**GuideDto Implementation:**
```csharp
using System.ComponentModel.DataAnnotations;

namespace TayNinhTourApi.BusinessLogicLayer.DTOs.Response.User
{
    /// <summary>
    /// DTO cho th√¥ng tin h∆∞·ªõng d·∫´n vi√™n
    /// S·ª≠ d·ª•ng trong dropdown selection v√† display
    /// </summary>
    public class GuideDto
    {
        /// <summary>
        /// ID c·ªßa h∆∞·ªõng d·∫´n vi√™n
        /// </summary>
        public Guid Id { get; set; }

        /// <summary>
        /// H·ªç t√™n ƒë·∫ßy ƒë·ªß
        /// </summary>
        public string FullName { get; set; } = null!;

        /// <summary>
        /// Email li√™n h·ªá
        /// </summary>
        public string Email { get; set; } = null!;

        /// <summary>
        /// S·ªë ƒëi·ªán tho·∫°i
        /// </summary>
        public string? PhoneNumber { get; set; }

        /// <summary>
        /// Tr·∫°ng th√°i ho·∫°t ƒë·ªông
        /// </summary>
        public bool IsActive { get; set; }

        /// <summary>
        /// C√≥ available cho assignment kh√¥ng
        /// (kh√¥ng b·ªã conflict v·ªõi tour kh√°c c√πng th·ªùi gian)
        /// </summary>
        public bool IsAvailable { get; set; }

        /// <summary>
        /// S·ªë nƒÉm kinh nghi·ªám
        /// </summary>
        public int? ExperienceYears { get; set; }

        /// <summary>
        /// Chuy√™n m√¥n/khu v·ª±c
        /// </summary>
        public string? Specialization { get; set; }

        /// <summary>
        /// Rating trung b√¨nh t·ª´ kh√°ch h√†ng
        /// </summary>
        public decimal? AverageRating { get; set; }

        /// <summary>
        /// S·ªë tour ƒë√£ d·∫´n
        /// </summary>
        public int CompletedTours { get; set; }

        /// <summary>
        /// Ng√†y tham gia
        /// </summary>
        public DateTime JoinedDate { get; set; }

        /// <summary>
        /// Tr·∫°ng th√°i hi·ªán t·∫°i (Available, Busy, OnLeave)
        /// </summary>
        public string CurrentStatus { get; set; } = "Available";
    }
}
```

**Business Logic cho IsAvailable:**
- Check guide kh√¥ng c√≥ tour conflict c√πng th·ªùi gian
- Check guide kh√¥ng trong tr·∫°ng th√°i ngh·ªâ ph√©p
- Check guide c√≥ active trong h·ªá th·ªëng

**Use Cases:**
1. **Dropdown selection**: Hi·ªÉn th·ªã danh s√°ch guides available
2. **Operation display**: Hi·ªÉn th·ªã th√¥ng tin guide ƒë√£ assign
3. **Guide management**: Qu·∫£n l√Ω th√¥ng tin guides

**Test:**
1. Compile project th√†nh c√¥ng
2. DTO c√≥ ƒë·∫ßy ƒë·ªß properties c·∫ßn thi·∫øt
3. Nullable fields ƒë∆∞·ª£c mark ƒë√∫ng

---

### üî• TASK 9: Th√™m Guide endpoints v√†o AccountController (25 ph√∫t)
**M·ª•c ti√™u:** Th√™m 2 endpoints cho Guide selection

**Context:** Extend AccountController ƒë·ªÉ support guide selection cho TourOperation. C·∫ßn logic ƒë·ªÉ check availability v√† filter guides ph√π h·ª£p.

**Files c·∫ßn s·ª≠a:**
- `TayNinhTourApi.Controller\Controllers\AccountController.cs`

**Endpoints Implementation:**

**1. GET /api/Account/guides - L·∫•y t·∫•t c·∫£ guides:**
```csharp
/// <summary>
/// L·∫•y danh s√°ch t·∫•t c·∫£ h∆∞·ªõng d·∫´n vi√™n
/// </summary>
/// <param name="includeInactive">C√≥ bao g·ªìm guides kh√¥ng active kh√¥ng</param>
/// <returns>Danh s√°ch guides</returns>
[HttpGet("guides")]
[Authorize(Roles = Constants.RoleTourCompanyName)]
[ProducesResponseType(typeof(List<GuideDto>), 200)]
public async Task<ActionResult<List<GuideDto>>> GetGuides(
    [FromQuery] bool includeInactive = false)
{
    try
    {
        _logger.LogInformation("Getting guides list, includeInactive: {IncludeInactive}", includeInactive);

        // L·∫•y users c√≥ role Guide
        var guides = await _unitOfWork.UserRepository.GetUsersByRoleAsync("Guide");

        if (!includeInactive)
        {
            guides = guides.Where(g => g.IsActive).ToList();
        }

        var guideDtos = guides.Select(guide => new GuideDto
        {
            Id = guide.Id,
            FullName = guide.FullName,
            Email = guide.Email,
            PhoneNumber = guide.PhoneNumber,
            IsActive = guide.IsActive,
            IsAvailable = true, // Default, s·∫Ω check chi ti·∫øt ·ªü endpoint kh√°c
            ExperienceYears = guide.ExperienceYears,
            Specialization = guide.Specialization,
            AverageRating = guide.AverageRating,
            CompletedTours = guide.CompletedTours,
            JoinedDate = guide.CreatedAt,
            CurrentStatus = guide.IsActive ? "Available" : "Inactive"
        }).OrderBy(g => g.FullName).ToList();

        _logger.LogInformation("Found {Count} guides", guideDtos.Count);
        return Ok(guideDtos);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error getting guides list");
        return StatusCode(500, new BaseResponseDto
        {
            IsSuccess = false,
            Message = "L·ªói h·ªá th·ªëng khi l·∫•y danh s√°ch h∆∞·ªõng d·∫´n vi√™n"
        });
    }
}
```

**2. GET /api/Account/guides/available - L·∫•y guides available cho ng√†y c·ª• th·ªÉ:**
```csharp
/// <summary>
/// L·∫•y danh s√°ch h∆∞·ªõng d·∫´n vi√™n available cho ng√†y c·ª• th·ªÉ
/// </summary>
/// <param name="date">Ng√†y c·∫ßn check availability</param>
/// <param name="excludeOperationId">Lo·∫°i tr·ª´ operation ID (khi update)</param>
/// <returns>Danh s√°ch guides available</returns>
[HttpGet("guides/available")]
[Authorize(Roles = Constants.RoleTourCompanyName)]
[ProducesResponseType(typeof(List<GuideDto>), 200)]
[ProducesResponseType(typeof(BaseResponseDto), 400)]
public async Task<ActionResult<List<GuideDto>>> GetAvailableGuides(
    [FromQuery] DateOnly date,
    [FromQuery] Guid? excludeOperationId = null)
{
    try
    {
        _logger.LogInformation("Getting available guides for date {Date}", date);

        if (date < DateOnly.FromDateTime(DateTime.Today))
        {
            return BadRequest(new BaseResponseDto
            {
                IsSuccess = false,
                Message = "Kh√¥ng th·ªÉ ch·ªçn ng√†y trong qu√° kh·ª©"
            });
        }

        // 1. L·∫•y t·∫•t c·∫£ guides active
        var allGuides = await _unitOfWork.UserRepository.GetUsersByRoleAsync("Guide");
        var activeGuides = allGuides.Where(g => g.IsActive).ToList();

        // 2. L·∫•y c√°c operations ƒë√£ c√≥ trong ng√†y ƒë√≥
        var existingOperations = await _unitOfWork.TourOperationRepository
            .GetOperationsByDateAsync(date);

        // 3. Lo·∫°i tr·ª´ operation ƒëang update (n·∫øu c√≥)
        if (excludeOperationId.HasValue)
        {
            existingOperations = existingOperations
                .Where(op => op.Id != excludeOperationId.Value)
                .ToList();
        }

        // 4. L·∫•y danh s√°ch guide IDs ƒë√£ busy
        var busyGuideIds = existingOperations
            .Where(op => op.GuideId.HasValue)
            .Select(op => op.GuideId.Value)
            .ToHashSet();

        // 5. Filter available guides
        var availableGuides = activeGuides
            .Where(guide => !busyGuideIds.Contains(guide.Id))
            .Select(guide => new GuideDto
            {
                Id = guide.Id,
                FullName = guide.FullName,
                Email = guide.Email,
                PhoneNumber = guide.PhoneNumber,
                IsActive = guide.IsActive,
                IsAvailable = true,
                ExperienceYears = guide.ExperienceYears,
                Specialization = guide.Specialization,
                AverageRating = guide.AverageRating,
                CompletedTours = guide.CompletedTours,
                JoinedDate = guide.CreatedAt,
                CurrentStatus = "Available"
            })
            .OrderBy(g => g.FullName)
            .ToList();

        _logger.LogInformation("Found {Count} available guides for {Date}", availableGuides.Count, date);
        return Ok(availableGuides);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error getting available guides for date {Date}", date);
        return StatusCode(500, new BaseResponseDto
        {
            IsSuccess = false,
            Message = "L·ªói h·ªá th·ªëng khi l·∫•y danh s√°ch h∆∞·ªõng d·∫´n vi√™n"
        });
    }
}
```

**Business Logic:**
1. **Role-based filtering**: Ch·ªâ l·∫•y users c√≥ role "Guide"
2. **Active status**: Filter theo IsActive status
3. **Date availability**: Check conflicts v·ªõi operations kh√°c c√πng ng√†y
4. **Exclude current operation**: Khi update, kh√¥ng t√≠nh operation hi·ªán t·∫°i

**Dependencies c·∫ßn th√™m:**
```csharp
// Th√™m v√†o constructor n·∫øu ch∆∞a c√≥
private readonly IUnitOfWork _unitOfWork;
```

**Repository methods c·∫ßn c√≥:**
- `GetUsersByRoleAsync(string roleName)`
- `GetOperationsByDateAsync(DateOnly date)`

**Test:**
1. Swagger hi·ªÉn th·ªã 2 endpoints m·ªõi v·ªõi documentation
2. Authorization middleware ho·∫°t ƒë·ªông
3. Date validation ho·∫°t ƒë·ªông
4. Business logic filter ƒë√∫ng guides available

---

### üî∂ TASK 10: C·∫≠p nh·∫≠t OpenAPI Documentation (20 ph√∫t)
**M·ª•c ti√™u:** C·∫≠p nh·∫≠t documentation cho APIs m·ªõi

**Files c·∫ßn s·ª≠a:**
- `TayNinhTourApi.Controller\Documentation\TourTemplate_OpenAPI.yaml`

**Th√™m schemas cho:**
- TourOperation endpoints
- Guide endpoints
- Updated GenerateSlots request

**Test:** Documentation ch√≠nh x√°c

---

### üî∂ TASK 11: Th·ªëng nh·∫•t DTOs (30 ph√∫t)
**M·ª•c ti√™u:** Lo·∫°i b·ªè duplicate RequestGenerateSlotsDto

**Files c·∫ßn x·ª≠ l√Ω:**
- Merge 3 DTOs th√†nh 1
- Update references
- Remove unused files

**Test:** Kh√¥ng c√≥ compile errors

---

### üîµ TASK 12: C·∫£i thi·ªán Error Messages (15 ph√∫t)
**M·ª•c ti√™u:** Standardize error responses

**Files c·∫ßn s·ª≠a:**
- Update error messages trong services
- Consistent error format

**Test:** Error responses nh·∫•t qu√°n

---

## üìä T·ªîNG K·∫æT TASKS

### üî• HIGH PRIORITY TASKS (9 tasks - ~3.5 gi·ªù):
- **TASK 1-2**: S·ª≠a Generate Slots Logic (45 ph√∫t)
- **TASK 3-7**: Implement TourOperation System (2 gi·ªù)
- **TASK 8-9**: Implement Guide Selection (40 ph√∫t)

### üî∂ MEDIUM PRIORITY TASKS (2 tasks - ~50 ph√∫t):
- **TASK 10-11**: Documentation & DTO cleanup

### üîµ LOW PRIORITY TASKS (1 task - ~15 ph√∫t):
- **TASK 12**: Error message improvements

### üìã EXECUTION ORDER:
1. **B·∫Øt ƒë·∫ßu v·ªõi TASK 1-2** (s·ª≠a logic c·ªët l√µi)
2. **Ti·∫øp t·ª•c TASK 3-7** (ho√†n thi·ªán TourOperation)
3. **Th·ª±c hi·ªán TASK 8-9** (Guide selection)
4. **K·∫øt th√∫c v·ªõi TASK 10-12** (polish & cleanup)

### ‚è±Ô∏è ESTIMATED TIME:
- **Total**: ~5 gi·ªù
- **Critical Path**: TASK 1-9 (~4 gi·ªù)
- **Optional**: TASK 10-12 (~1 gi·ªù)

---

## üéØ K·∫æT LU·∫¨N

### Tr∆∞·ªõc khi th·ª±c hi·ªán tasks (85% ho√†n th√†nh):
- ‚úÖ Template CRUD ho√†n ch·ªânh
- ‚úÖ Timeline management ho√†n ch·ªânh
- ‚úÖ Shop integration ho√†n ch·ªânh
- ‚úÖ Slot generation ho√†n ch·ªânh (nh∆∞ng logic sai)
- ‚úÖ Scheduling algorithm ho√†n ch·ªânh
- ‚úÖ Template copy functionality
- ‚ùå TourOperation CRUD APIs
- ‚ùå Guide/User selection APIs

### Sau khi ho√†n th√†nh tasks (100% ho√†n th√†nh):
- ‚úÖ Template CRUD ho√†n ch·ªânh
- ‚úÖ Timeline management ho√†n ch·ªânh
- ‚úÖ Shop integration ho√†n ch·ªânh
- ‚úÖ Slot generation v·ªõi logic ƒê√öNG (l·∫•y ng√†y t·ª´ template)
- ‚úÖ Scheduling algorithm ho√†n ch·ªânh
- ‚úÖ Template copy functionality
- ‚úÖ TourOperation CRUD APIs
- ‚úÖ Guide/User selection APIs

**V·ªõi 12 tasks n√†y, project s·∫Ω ƒë·∫°t 100% requirement v√† logic s·∫Ω ho√†n to√†n ƒë√∫ng theo y√™u c·∫ßu ban ƒë·∫ßu: Template ƒë·ªãnh nghƒ©a ng√†y c·ªë ƒë·ªãnh, ch·ªâ c·∫ßn ch·ªçn th√°ng/nƒÉm khi generate slots.**

---

**Ng√†y t·∫°o**: 06/06/2025
**T√°c gi·∫£**: Task breakdown t·ª´ ph√¢n t√≠ch requirement
**Tr·∫°ng th√°i**: Ready to execute - 12 tasks chi ti·∫øt
**∆Ø·ªõc t√≠nh th·ªùi gian**: 5 gi·ªù (4 gi·ªù critical + 1 gi·ªù optional)

### Tr∆∞·ªõc khi c·∫£i thi·ªán (85% ho√†n th√†nh):
- ‚úÖ Template CRUD ho√†n ch·ªânh
- ‚úÖ Timeline management ho√†n ch·ªânh
- ‚úÖ Shop integration ho√†n ch·ªânh
- ‚úÖ Slot generation ho√†n ch·ªânh (nh∆∞ng logic sai)
- ‚úÖ Scheduling algorithm ho√†n ch·ªânh
- ‚úÖ Template copy functionality
- ‚ùå TourOperation CRUD APIs
- ‚ùå Guide/User selection APIs

### Sau khi c·∫£i thi·ªán (100% ho√†n th√†nh):
- ‚úÖ Template CRUD ho√†n ch·ªânh
- ‚úÖ Timeline management ho√†n ch·ªânh
- ‚úÖ Shop integration ho√†n ch·ªânh
- ‚úÖ Slot generation v·ªõi logic ƒê√öNG (l·∫•y ng√†y t·ª´ template)
- ‚úÖ Scheduling algorithm ho√†n ch·ªânh
- ‚úÖ Template copy functionality
- ‚úÖ TourOperation CRUD APIs
- ‚úÖ Guide/User selection APIs

**V·ªõi nh·ªØng c·∫£i thi·ªán n√†y, project s·∫Ω ƒë·∫°t 100% requirement v√† logic s·∫Ω ho√†n to√†n ƒë√∫ng theo y√™u c·∫ßu ban ƒë·∫ßu: Template ƒë·ªãnh nghƒ©a ng√†y c·ªë ƒë·ªãnh, ch·ªâ c·∫ßn ch·ªçn th√°ng/nƒÉm khi generate slots.**

---

**Ng√†y t·∫°o**: 06/06/2025
**T√°c gi·∫£**: Ph√¢n t√≠ch d·ª±a tr√™n review v√† requirement
**Tr·∫°ng th√°i**: Plan ƒë·ªÉ ƒë·∫°t 100% requirement